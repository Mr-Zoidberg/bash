#!/usr/bin/env bash

# TODOS:
# check branches for wip?

DEFAULT_PROJECT_DIR=${SWEEPWIP_DIR:-${HOME}/Projects}
PROJECTS_DIR=${1:-${DEFAULT_PROJECT_DIR}}

usage() {
  [[ -n ${1} ]] && echo -e "** ${1}\n"
  cat <<EOU
Scans directories for '.git' and outputs the state of the local git repository.

Usage $(basename $0) [ -h|--help ] [DIR_TO_SCAN] [ -b ] [ -a ] [ -f ] [ -M ] [ -P ] [ -l ] [ -R ] [ -u ]

DIR_TO_SCAN     Directory where find projects  managed by git, currently it
                defaults to "${DEFAULT_PROJECT_DIR}", you can change it by
                setting the environment variable SWEEPWIP_DIR.

Note: To use an option bellow, DIR_TO_SCAN has to be defined on the command line. Uppercase
options like -M will supress behavior that is eneable by default, lowercase options do the oposite.

-h|--help       This message
-a              Shows log messages of commits ahead
-b              Shows log messages of commits behind
-f              Perform 'git fetch'
-M              Supress local changes check, this will supress -l
-l              List details of local changes
-P              Supress local push/pull differences
-R              Supress check for remotes
-u              Try fast-forward changes (git merge --ff-only)

EOU
 exit
}

# be compatible with GNU help style.
[[ ${1} == "--help" ]] && usage

while getopts “h” OPTION; do
  case $OPTION in
    h) usage;;
    \?) usage "You must pass DIR_TO_SCAN in order to use parameters.";;
  esac
done

check_project() {
  # remove first argument only if a dir was given
  # this fixes problems with the other arguments parsing
  [[ $* =~ ^-d ]] || shift

  # Options...
  LIST_COMMITS_AHEAD=
  LIST_COMMITS_BEHIND=
  PERFORM_GIT_FETCH=
  LIST_LOCAL_CHANGES=
  FAST_FORWARD_CHANGES=
  LOCAL_CHANGES=true
  CHANGES_NOT_PUSHED=true
  REMOTE_NOT_DEFINED=true

  function _flip_option() { [[ ${1} == 'true' ]] && echo '' || echo 'true'; }

  while getopts “p:d:fMPRluab” OPTION
  do
    case $OPTION in
      d) PROJECTS_DIR=${OPTARG};;
      p) PROJECT=${OPTARG};;
      f) PERFORM_GIT_FETCH=$(_flip_option ${PERFORM_GIT_FETCH});;
      M) LOCAL_CHANGES=$(_flip_option ${LOCAL_CHANGES});;
      l) LIST_LOCAL_CHANGES=$(_flip_option ${LIST_LOCAL_CHANGES});;
      P) CHANGES_NOT_PUSHED=$(_flip_option ${CHANGES_NOT_PUSHED});;
      R) REMOTE_NOT_DEFINED=$(_flip_option ${REMOTE_NOT_DEFINED});;
      u) FAST_FORWARD_CHANGES=$(_flip_option ${FAST_FORWARD_CHANGES});;
      a) LIST_COMMITS_AHEAD=$(_flip_option ${LIST_COMMITS_AHEAD});;
      b) LIST_COMMITS_BEHIND=$(_flip_option ${LIST_COMMITS_BEHIND});;
    esac
  done

  local search_dir=${PROJECTS_DIR}  # the root from where we start our search
  local project_dir=${PROJECT%.git} # the dir found with .git striped

  function _colored()  { tput setaf ${1}; echo -e ${2}; tput sgr0; }
  function in_red()    { _colored 1 "${1}"; }
  function in_green()  { _colored 2 "${1}"; }
  function in_yellow() { _colored 3 "${1}"; }
  function in_cyan()   { _colored 6 "${1}"; }

  function proj_name() {
    local name=${project_dir#${search_dir}}

    # restore name if search_dir is the same as the project_dir
    [[ ${name} == "/" ]] && name=${search_dir}

    name=${name#/} # remove leading '/'
    name=${name%/} # remove trailing '/'
    echo ${name}
  }

  function dirty_git_status() {
    local status=$(git status -s)
    if [[ ${status} != "" ]]; then
      in_yellow "LOCAL CHANGES NOT COMMITED"
      while read line; do
        [[ -n ${LIST_LOCAL_CHANGES} ]] && echo -e "\t${line}"
      done <<<"${status}"
    fi
  }

  function git_changes_not_pushed() {
    local status=$(git status -sb)
    local re='ahead ([0-9]+)'
    if [[ ${status} =~ ${re} ]]; then
      in_red "COMMITS AHEAD: ${BASH_REMATCH[1]}"
      [[ -n ${LIST_COMMITS_AHEAD} ]] && \
        git log --format=oneline --abbrev-commit origin/master..master \
        | while read line; do echo -e "\t${line}"; done
    fi
    re='behind ([0-9]+)'
    if [[ ${status} =~ ${re} ]]; then
      in_cyan "COMMITS BEHIND: ${BASH_REMATCH[1]}"
      [[ -n ${LIST_COMMITS_BEHIND} ]] && \
        git log --format=oneline --abbrev-commit master..origin/master \
        | while read line; do echo -e "\t${line}"; done
    fi
  }

  function git_remote_defined() {
    if [[ $(git remote) == "" ]]; then
      in_red "NO REMOTES DEFINED"
    fi
  }

  # main execution
  local project_name=$(proj_name)
  in_green ">>> ${project_name} <<<"
  (cd ${project_dir}
    [[ -n ${PERFORM_GIT_FETCH} ]]    && git fetch -q
    [[ -n ${FAST_FORWARD_CHANGES} ]] && git merge --ff-only
    [[ -n ${CHANGES_NOT_PUSHED} ]]   && git_changes_not_pushed
    [[ -n ${LOCAL_CHANGES} ]]        && dirty_git_status
    [[ -n ${REMOTE_NOT_DEFINED} ]]   && git_remote_defined
  )
}

export -f check_project # make this available for find

find -L "${PROJECTS_DIR}"  -type d -name '.git' -exec bash -c "check_project $* -d ${PROJECTS_DIR} -p '{}' " \;

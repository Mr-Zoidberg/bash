#!/usr/bin/env bash

# TODOS:
# check if the project has a remote to push to
# check branches for wip?

DEFAULT_PROJECT_DIR=${HOME}/Projects

PROJECTS_DIR=${1:-${DEFAULT_PROJECT_DIR}}

usage() {
  cat <<EOU
Scans directories for '.git' and outputs the state of the local git repository.

Usage $0 [ -h|? ] [DIR_TO_SCAN] [ -f ] [ -M ] [ -P ] [ -l ] [ -R ]

DIR_TO_SCAN     Directory where to find projects that are managed by git,
                defaults to "${DEFAULT_PROJECT_DIR}", you can change it
                by modifying DEFAULT_PROJECT_DIR in this script.

Note: To use an option bellow, DIR_TO_SCAN has to be defined.

-h|?            This message.
-f              Perform 'git fetch', by default disabled.
-M              Supress local changes check, this will supress -l.
-l              List details of local changes.
-P              Supress local push/pull differences.
-R              Supress check for remotes.

EOU
}
while getopts “h?” OPTION; do
  case $OPTION in
    h|?) usage; exit;;
  esac
done

check_project() {
  # remove first argument only if a dir was given
  # this fixes problems with the other arguments parsing
  [[ $* =~ ^-d ]] || shift

  # Options...
  PERFORM_GIT_FETCH=
  LOCAL_CHANGES=true
  LIST_LOCAL_CHANGES=
  CHANGES_NOT_PUSHED=true
  REMOTE_NOT_DEFINED=true

  function _flip_option() { [[ ${1} == 'true' ]] && echo '' || echo 'true'; }

  while getopts “p:d:fMPRl” OPTION
  do
    case $OPTION in
      d) PROJECTS_DIR=${OPTARG};;
      p) PROJECT=${OPTARG};;
      f) PERFORM_GIT_FETCH=$(_flip_option ${PERFORM_GIT_FETCH});;
      M) LOCAL_CHANGES=$(_flip_option ${LOCAL_CHANGES});;
      l) LIST_LOCAL_CHANGES=$(_flip_option ${LIST_LOCAL_CHANGES});;
      P) CHANGES_NOT_PUSHED=$(_flip_option ${CHANGES_NOT_PUSHED});;
      R) REMOTE_NOT_DEFINED=$(_flip_option ${REMOTE_NOT_DEFINED});;
    esac
  done

  local search_dir=${PROJECTS_DIR}  # the root from where we start our search
  local project_dir=${PROJECT%.git} # the dir found with .git striped

  function _colored()  { tput setaf ${1}; echo -e ${2}; tput sgr0; }
  function in_red()    { _colored 1 "${1}"; }
  function in_green()  { _colored 2 "${1}"; }
  function in_yellow() { _colored 3 "${1}"; }
  function in_cyan()   { _colored 6 "${1}"; }

  function proj_name() {
    local name=${project_dir#${search_dir}}

    # restore name if search_dir is the same as the project_dir
    [[ ${name} == "/" ]] && name=${search_dir}

    name=${name#/} # remove leading '/'
    name=${name%/} # remove trailing '/'
    echo ${name}
  }

  function dirty_git_status() {
    local status=$(git status -s)
    if [[ ${status} != "" ]]; then
      in_yellow "LOCAL CHANGES NOT COMMITED"
      while read line; do
        [[ -n ${LIST_LOCAL_CHANGES} ]] && echo -e "\t${line}"
      done <<<"${status}"
    fi
  }

  function git_changes_not_pushed() {
    local status=$(git status -sb)
    local re='ahead ([0-9]+)'
    if [[ ${status} =~ ${re} ]]; then
      in_red "COMMITS AHEAD: ${BASH_REMATCH[1]}"
    fi
    re='behind ([0-9]+)'
    if [[ ${status} =~ ${re} ]]; then
      in_cyan "COMMITS BEHIND: ${BASH_REMATCH[1]}"
    fi
  }

  function git_remote_defined() {
    if [[ $(git remote) == "" ]]; then
      in_red "NO REMOTES DEFINED"
    fi
  }

  local project_name=$(proj_name)
  in_green ">>> ${project_name} <<<"
  (cd ${project_dir}
    [[ -n ${PERFORM_GIT_FETCH} ]]  && git fetch -q
    [[ -n ${CHANGES_NOT_PUSHED} ]] && git_changes_not_pushed
    [[ -n ${LOCAL_CHANGES} ]]      && dirty_git_status
    [[ -n ${REMOTE_NOT_DEFINED} ]] && git_remote_defined
  )
}

export -f check_project # make this available for find

find -L "${PROJECTS_DIR}"  -type d -name '.git' -exec bash -c "check_project $* -d ${PROJECTS_DIR} -p '{}' " \;

#!/usr/bin/env bash

# TODOS:
# check if the project has a remote to push to
# check branches for wip?

PROJECTS_DIR=${1:-${HOME}/Projects}

check_project() {
  local search_dir=${1}       # the root from where we start our search
  local project_dir=${2%.git} # the dir found with .git striped

  function _colored()  { tput setaf ${1}; echo -e ${2}; tput sgr0; }
  function in_red()    { _colored 1 "${1}"; }
  function in_green()  { _colored 2 "${1}"; }
  function in_yellow() { _colored 3 "${1}"; }
  function in_cyan()   { _colored 6 "${1}"; }

  function proj_name() {
    local name=${project_dir#${search_dir}}
    name=${name#/} # remove leading '/'
    name=${name%/} # remove trailing '/'
    echo ${name}
  }

  function dirty_git_status() {
    local status=$(git status -s)
    if [[ ${status} != "" ]]; then
      in_yellow "LOCAL CHANGES NOT COMMITED"
      while read line; do
        [[ ${VERBOSE} != "" ]] && echo -e "\t${line}"
      done <<<"${status}"
    fi
  }

  function git_changes_not_pushed() {
    #git fetch -q
    local status=$(git status -sb)
    local re='ahead ([0-9]+)'
    if [[ ${status} =~ ${re} ]]; then
      in_red "COMMITS AHEAD: ${BASH_REMATCH[1]}"
    fi
    re='behind ([0-9]+)'
    if [[ ${status} =~ ${re} ]]; then
      in_cyan "COMMITS BEHIND: ${BASH_REMATCH[1]}"
    fi
  }

  local project_name=$(proj_name)

  in_green ">>> ${project_name} <<<"
  (cd ${project_dir}
    git_changes_not_pushed
    dirty_git_status
  )
}

export -f check_project

find -L "${PROJECTS_DIR}"  -type d -name '.git' -exec bash -c "check_project '${PROJECTS_DIR}' '{}' " \;
